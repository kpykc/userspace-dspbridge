;
;  ======== mgs3/acpy2_isr.s55 ========
;
; This file implements various ISR routines functions
;
;
;
;------------------------------------------------------------------------------------------
;  History:
;     Mar 24, 2005 by Craig Leeds
;       Further Optimizations applied:
;          Whenever data is accessed via indirect auxiliary register offset,
;          the "short" modifier was used if it was possible.  This would shrink the
;          the instruction by 2 bytes, though not necessarily change the number of 
;          cycles required to execute the instruction.  However, in shrinking the
;          the number of bytes, it lessens the possibility of a pipeline delay
;          due to a pre-fetch IBQ delay.  This optimization was applied in several 
;          instuctions.
;
;          Use BSET instead of OR to set a single bit in an accumulator.  The instruction
;          is one byte smaller.
;
;          Instructions were rearranged to allow for pipeline delays to be satisfied
;          without on-the-fly NOPs being inserted.  This was done for the usage of
;          AR registers for indirect access after being set.  
;
;          Combinable instructions were paralleled together assuming there were no
;          obvious pipeline delay repercussions.
;
;          In one place, ADD was modified to AADD in order to allow parallel instructions.
;          Conversely, AADD might be changed to ADD to shrink instruction size if no other
;          pipeline delay was introduced, in order to mitigate potential IBQ pre-fetch delays.
;
;          Writes to the DMA registers were staggered as much as possible to avoid
;          pipeline delays for back-to-back writes.
;
;          The job queue buffer was modified.  A new element 'nextJob' was added 
;          which points to the next physical job in the buffer.  The last job 
;          points back to the first.  This simplifies the circular addressing.  
;          Hence, the 'buffer' and lenM1' elements could be removed from the 
;          queue object.
;
;          The methodology for determining if there are no pending jobs was changed from
;          a readPtr->dst of 0 to readPtr = writePtr.  This made the determination a
;          little faster and removed the necessity of clearing the dst element after
;          the pending job had been started.
;
;       Bugs were fixed if a callback function was enabled.  
;          The stack was not being aligned properly on entry to a callback function.
;          THe M40, SATD, C16, FRCT, and 54CM bits status bits in ST1 needed to be turned off.
;          The SATA and SMUL status bits in ST3 needed to be turned off and on respectively.
;          The following registers that may be modified by the callback function were
;          not being saved and restored:
;                TRN0,TRN1,XCDP,BK03,BK47,BKC,
;                BSA01,BSA23,BSA45,BSA67,BSAC,
;                RSA0H,REA0H,RSA1H,REA1H
;          Note that if _INSTR_BANDWIDTH is turned on, the same care was not taken to 
;          prepare for calling the instrumentation routine.  Only a subset of these
;          registers needed to be saved and restored.  This is because the 
;          instrumentation routine _ACPY2_OMAP_updateChannelStats() is owned
;          by this project, and we can limit what registers we use in that routine.
;          However, to guarantee incompatibilities due to future compiler 
;          enhancements, converting ACPY2_OMAP_updateChannelStats() to
;          assembly language might be advisable.
;
;    Total code size reduced from 4584 to 2524 bytes.  The bulk of this was
;    accomplished by merging the callback functionality for all 6 ISRs into
;    the same code.
;
;    Conditional assembly added to optimize the code for size rather than speed. 
;    Resulting program requires 2 to 5 extra cycles to execute, but is 
;    ultimately reduced to 1208 bytes from 2524.  And only 458 of these bytes
;    need to be in RAM.  The 750 bytes of the callback code can be in external memory.
;
;    Modified callback shell to allow for BIOS calls within the callback function
;
;------------------------------------------------------------------------------------------

OPTIMIZE_FOR_SIZE .equ 1  ; Optimize for a small footprint instead of fastest code.
                          ; Unless you are desparate for 5 ticks, it's best to set it to 1.

 .if (!$isdefed("DMA_OPT"))
DMA_OPT .equ 0        ; if not defined
 .endif

 .if (!$isdefed("OPTIMIZE_FOR_SIZE"))
OPTIMIZE_FOR_SIZE .equ 0
 .endif

    .if DMA_OPT

;==============================================================================
;includes
;------------------------------------------------------------------------------

    .include hwi.h55
    .include "dma_omap.h55"

 .if (!$isdefed("_INSTR_BANDWIDTH"))
_INSTR_BANDWIDTH .equ 0        ; if not defined
 .endif
 
;/d============================================================================
;/d function prototype and global variables
;/d----------------------------------------------------------------------------
    .global     __DMA_jobQueue
    .ref        DMA_Port_consts

 .if _INSTR_BANDWIDTH
        .ref        _ACPY2_OMAP_updateChannelStats
 .endif

ACPY2_callbackPtr    .usect    ".bss:ACPY_internal",2,1  ; &IDMA2_Obj.cbFxn

;/d============================================================================
;/d defines and macros
;/d----------------------------------------------------------------------------

    .def _dmanIsr0
    .def _dmanIsr1
    .def _dmanIsr2
    .def _dmanIsr3
    .def _dmanIsr4
    .def _dmanIsr5

;/d============================================================================
;/d macros
;/d----------------------------------------------------------------------------

* SAVE_CONTEXT_FOR_MY_C and RESTORE_CONTEXT_FOR_MY_C can only be used
* for setting up for calling C-callable routines in this project where
* we know what registers are going to be assumed and modified.
* These macros cannot be used for generic C routines.
*
* The following registers must be preserved by any C-callable 
* routine, so they do not need to be saved and restored here.
*     XAR5, XAR6, XAR7, T2, T3, RETA, CFCT, XDP,
*     MDP, MDP05, MDP67
*  The following registers have already been saved in the ISR:
*     XAR0, XAR1, XAR2, XAR3, XAR4, AC0, AC1, AC2, AC3,
*     T0, T1
*  The following registers are saved by Automatic Context Switch
*     ST0_55, ST1_55, ST2_55
*  The following registers will not be modified by our own routines:
*     TRN0, TRN1, XCDP, 
*     BK03, BK47, BKC,
*     BSA01, BSA23, BSA45, BSA67, BSAC,
*     BRS1, BRC0, BRC1, 
*     RSA0H, RSA0L, REA0H, REA0L,
*     RSA1H, RSA1L, REA1H, REA1L
*  Since SATA and SMUL are neither used nor modified by my own routine,
*  ST3 does not need to be saved and modified and later restored,
*
*  Presumably, no doubles nor pointers will be placed on the stack,
*  so the stack need not be aligned.  This is a bit scary though.
*     
SAVE_CONTEXT_FOR_MY_C          .macro
* Modify ST1 for a C-callable routine
    OR  #0x4900, mmap(ST1_55)    ; Turn on CPL, INTM, SXMD 
*                                ; Don't touch XF, HM, ASM    

    ;save status
;;;    PSH mmap(@ST3_L)         ; not needed for my own C routine (SATA,SMUL)

    PSH mmap(@RPTC)
    PSH mmap(@CSR_L)
* Align stack on even
    MOV SP, AR1
    BTSTCLR #0,mmap(SP),TC1      ; align stack on even (ignore TC1)
    AADD #-1,SP
    PSH AR1

 .endm 

RESTORE_CONTEXT_FOR_MY_C .macro
; restore stack (needed because of alignment)
    POP mmap(SP)              ; restore stack
    POP mmap(@CSR_L)
    POP mmap(@RPTC)

    ;restore status
;;;    POP mmap(@ST3_L)         ; not needed for my own C routine (SATA,SMUL)

 .endm
 
 
 
;;;;;;;;;;;;;;;;;;;;
* The following registers must be preserved by any C-callable 
* routine, so they do not need to be saved and restored here.
*     XAR5, XAR6, XAR7, T2, T3, RETA, CFCT, XDP,
*     MDP, MDP05, MDP67
*  The following registers have already been saved globally in the ISRs:
*     XAR1, XAR2, XAR4, AC1, AC2, 
*  The following registers are saved by Automatic Context Switch
*     ST0_55, ST1_55, ST2_55
*
SAVE_CONTEXT_FOR_C          .macro
* Modify ST1 for a C-callable routine
    PSHBOTH XAR0
    PSH dbl(mmap(@RSA0_H))       ; and RSA0_L
    OR  #0x4900, mmap(ST1_55)    ; Turn on CPL, INTM, SXMD 
*                                ; Don't touch XF, HM, ASM    
    PSH mmap(@ST3_L)             ;save non-automatic status
    PSH mmap(@RPTC)
    PSH dbl(mmap(@REA0_H))       ; and REA0_L

    PSH dbl(AC3)
    PSH mmap(AC3G)
    PSH dbl(AC0)
    ||BCLR ST3_SATA              ; SATA=0 for C
    PSH mmap(AC0G)
    PSH dbl(mmap(@REA1_H))       ; and REA1_L
    PSHBOTH XAR3
    ||BSET ST3_SMUL              ; SMUL=1 for C
    PSH dbl(mmap(@BK47))         ; and BKC
    PSH T1, T0
    PSHBOTH XCDP
    PSH dbl(mmap(@BRS1_L))       ; and CSR_L (must occur before BRC1)
    PSH mmap(@BRC0_L)            ; 
    PSH dbl(mmap(@TRN1))         ; and BRC1_L
    PSH mmap(@TRN0)              ; 
    PSH dbl(mmap(@RSA1_H))       ; and RSA1_L
    PSH mmap(@BK03)              ; 
    PSH dbl(mmap(@BSA01))        ; and BSA23
    PSH mmap(@BSAC)              ; 
    PSH dbl(mmap(@BSA45))        ; and BSA67
* Align stack on even
    MOV SP, AR1
    BTSTCLR #0,mmap(SP),TC1      ; align stack on even (ignore TC1)
    AADD #-1,SP
    PSH AR1
 .endm 

RESTORE_CONTEXT_FOR_C .macro
; restore stack (needed because of alignment)
    POP    mmap(SP)              ; restore stack
; restore modifiable memory-mapped registers
    POP dbl(mmap(@BSA45))        ; and BSA67
    POP mmap(@BSAC)              ; 
    POP dbl(mmap(@BSA01))        ; and BSA23
    POP mmap(@BK03)              ; 
    POP dbl(mmap(@RSA1_H))       ; and RSA1_L
    POP mmap(@TRN0)              ; 
    POP dbl(mmap(@TRN1))         ; and BRC1_L
    POP mmap(@BRC0_L)            ; 
    POP dbl(mmap(@BRS1_L))       ; and CSR_L (must occur after BRC1)
    POPBOTH XCDP
    POP T1, T0  
    POP dbl(mmap(@BK47))         ; and BKC
    POPBOTH XAR3
    POP dbl(mmap(@REA1_H))       ; and REA1_L
    POP mmap(AC0G)
    POP dbl(AC0)
    POP mmap(AC3G)
    POP dbl(AC3)
    POP dbl(mmap(@REA0_H))       ; and REA0_L
    POP mmap(@RPTC)
    POP mmap(@ST3_L)             ;restore non-automatic status
    POP dbl(mmap(@RSA0_H))       ; and RSA0_L
    POPBOTH XAR0

 .endm
;;;;;;;;;;;;;;;;;;;;



DMAN_EPILOG_MAC    .macro    ; Restore registers and exit from ISR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Final cleanup after these ISRs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Context restoring XAR1, XAR2, AC2, XAR4
; Context restoring XAR1, XAR2, AC2, XAR4
    POPBOTH XAR2
    POP mmap(AC2G)
    POP dbl(AC2)
    POPBOTH XAR4
*
* Note: ST0, ST1, ST2 do not need restoring.  They
* are automatically restored by the Automatic Context Switch
* mechanism of an ISR.
*
    .endm
    




    
DMA_GUTS_MAC  .macro  ChNum, LABEL1, LABEL3 ; the common guts of the DMA isr
    PSHBOTH XAR1
    
 .if (_DMA_QueueObj.curHandle == 0)
    MOV dbl(*AR4), XAR2                                   ; XAR2 = jobQ->curHandle
 .else   
    MOV dbl(*AR4(short(#_DMA_QueueObj.curHandle))), XAR2  ; XAR2 = jobQ->curHandle
 .endif   
    MOV dbl(*AR4(short(#_DMA_QueueObj.readPtr))), XAR1    ; XAR1 = jobQ->readPtr
    
    PSH dbl(AC1)
    PSH mmap(AC1G)

    ; Pull out the job from the queue if any
    ;job = peek(jobQ);
    XOR *AR4(#_DMA_QueueObj.writePtr+1), AR1, AC2     ; AC2 = 0 if readPtr = writePtr
    ;job = jobQ->readPtr;
    ; Decrement job count for both the logical channel and physical channel
    ;jobQ->reqPending--
    
 .noremark 5571 ; CPU_41 This instruction may corrupt carry bit (but carry is ignored!)
    SUB #1, *AR4(short(#_DMA_QueueObj.reqPending))
 .remark 5571

    ;jobQ->curHandle->numJobs--
 .noremark 5571 ; CPU_41 This instruction may corrupt carry bit (but carry is ignored!)
  .if (IDMA2_Obj.numJobs == 0)
    SUB #1, *AR2     ; jobQ->curHandle->numJobs--
  .else
    SUB #1, *AR2(short(#IDMA2_Obj.numJobs))
  .endif
 .remark 5571

    ;if (jobQ->readPtr != jobQ->writePtr) {
    ;    DMA_load(job->handle, job->src, job->dst, job->cnt);
    ;    updateQueue(_DMA_jobQueue[chanNum]);
    ;}

  .if _INSTR_BANDWIDTH
    ;  when instrumented, branch to different label where we call
    ;  ACPY2_OMAP_updateChannelStats with NULL handle
    ;
    BCC LABEL3, AC2 != #0         ; if(job!=0), skip to label

    ;  ******* instrumentation call for DMA bandwidth data *******
    ;       ACPY2_OMAP_updateChannelStats(handle, cnt);
    ;           handle          ;IDMA2_handle, passed in XAR0
    ;           Cnt             ; unsigned Count, passed in T0
    ;       Restore AR0 and TO, and we don't need to preserve
    ;       anything else modified by updateChannelStats ...

    ;  CALL ACPY2_OMAP_updateChannelStats with NULL handle
    ;  ***************************************
    ; 
    PSHBOTH XAR0
   .if (OPTIMIZE_FOR_SIZE == 0)
    PSH T1, T0  ; save 
    MOV #(ChNum >> 1), T0   ; CASE 1: pass ChanId in cnt argument with 
                            ; handle == NULL, ChNum is ChannelNumber*2
   .endif

* Craig Leeds 1/9/05
*   ACPY2_OMAP_updateChannelStats is a routine owned by this project,
*   It calls no other function and is written in C.
*   So some assumptions can be made on what registers will be used and
*   what alignment is necessary.  

    PSHBOTH XAR3
    PSH dbl(AC0)
    PSH dbl(AC3)
    PSH mmap(AC0G)
    PSH mmap(AC3G)
 .noremark 5573  ; CPU_43 BKxx & BSAxx updates not pipeline protected against MAR ops
    AMOV #0, XAR0
 .remark 5573
    
    SAVE_CONTEXT_FOR_MY_C
    CALL #_ACPY2_OMAP_updateChannelStats 
    RESTORE_CONTEXT_FOR_MY_C
    
    POP mmap(AC3G)
    POP mmap(AC0G)
    POP dbl(AC3)
    POP dbl(AC0)
    POPBOTH XAR3
   .if (OPTIMIZE_FOR_SIZE == 0)
    POP T1, T0  ; restore
   .endif
    POPBOTH XAR0
    ||B    LABEL1        ; if(job==0), branch to end of function 
    
* (Craig Leeds 1/19/05)
*   No need to branch conditionally since condition is always true if 
*   fell thru prior BCC,  and condition is always false if branched
*   on prior BCC.

    
    ; end-of _INSTR_BANDWIDTH

LABEL3:
  .else ; if _INSTR_BANDWIDTH

    BCC LABEL1, AC2 == #0         ; if(job==0), branch to end of function
    PSHBOTH XAR0
  .endif ; if _INSTR_BANDWIDTH ; else

    ; Context saving AC3, AC0, XAR3, T1, T0
    PSH dbl(AC3)
    PSH mmap(AC3G)
;;;    PSH dbl(AC0) || XOR AC3     ; AC3 = 0
    PSH dbl(AC0)
    PSH mmap(AC0G)
    PSHBOTH XAR3 
  .if (_INSTR_BANDWIDTH == 0) | (OPTIMIZE_FOR_SIZE == 0)
    PSH T1, T0
  .endif

    ;Set arguments for #_DMA_load
    MOV dbl(*AR1(short(#_DMA_Job.handle))), XAR0       ; AR0 = job->handle
    MOV dbl(*AR1+), pair(T0)                           ; T0 = job->cnt, T1 = dummy
*                                                      ; AR1 = &job->src    
    MOV dbl(*AR1+), AC0                                ; AC0 = job->src
*                                                      ; AR1 = &job->dst    
    MOV dbl(*AR1), AC1                                 ; AC1 = job->dst (Pipe 4 just Ok for XAR1 from MOV)

    ;updateQueue(_DMA_jobQueue[chanNum]);

  .if _INSTR_BANDWIDTH
    ;  save handle(XAR0) and cnt(T0) on stack, to be used later to
    ;  call ACPY2_OMAP_updateChannelStats
    PSHBOTH XAR0   ; AR0 == job->handle        ; 
    PSH T0         ; T0  == job->cnt        ;
  .endif

;******************************************************************************
;* Portion NAME: _updateQueue                                                 *
;* Remove job and update readPtr.                                             *
;* Called with interrupts disabled.                                           *
;* Function Uses Regs : AC2,AC3,XAR1,XAR3,XAR4                                *
;******************************************************************************

;;;* Note: the following line setting job->dst to 0 is no longer necessary
;;;    MOV AC3,dbl(*AR1)                                  ; job->dst = NULL
    
    MOV dbl(*AR1(short(#_DMA_Job.nextJob-_DMA_Job.dst))),AC2 ; AC2 = job->nextJob
    MOV dbl(*AR0(short(#IDMA2_Obj.jobQueue))), XAR1    ; handle->jobQueue (Pipe 4 just Ok for AR0 from MOV)
    PSH T3, T2
    MOV AC2, dbl(*AR4(short(#_DMA_QueueObj.readPtr)))  ; queue->readPtr = job->nextJob

    ; Inline assembly version of "DMA_load" function
        
;******************************************************************************
;* Portion NAME: _DMA_load                                                    *
;* If the DMA is idle, program it according to job and start the transfer     *
;* Called with interrupts disabled                                            *
;* Function Uses Regs : AC0,AC1,AC2,AC3,T0,T1,T2,T3,XAR0,XAR1,XAR2,XAR3,XAR4  *
;******************************************************************************
    MOV #DMA_ChBase, AC3                        ; AC3 = Base address for
                                                ;     DMA channel registers

    ;regs = dmaChan_dman[handle->channel];
    ADD *AR0(short(#IDMA2_Obj.channel)) << #5, AC3 ; AC3 = AC3 + handle->channel * 32
    MOV AC3, XAR3                               ; XAR3 = AC3 = regs
    MOV AC3, XAR4                               ; XAR4 = AC3 = regs
;******** Save XAR2 (curhandle) to get the Callback Notification fxn ******
    ||PSH AR2                                   ; don't need to save AR2H since it isn't modified

    ; handle->jobQueue->curHandle = handle
 .if (_DMA_QueueObj.curHandle == 0)
    MOV XAR0, dbl(*AR1)                                  ; Pipe 4 just Ok from MOV for AR1
 .else   
    MOV XAR0, dbl(*AR1(short(#_DMA_QueueObj.curHandle))) ; Pipe 4 just Ok from MOV for AR1
 .endif   

 .noremark 5573  ; CPU_43 BKxx & BSAxx updates not pipeline protected against MAR ops
    AMOV #DMA_Port_consts, XAR1                 ; XAR1 = Address of OMAP
                                                ;    specific "DMA_Port_consts"
 .remark 5573
 
;********* Calculate Src Port Value *******

    SUB dbl(*AR1+), AC0, AC3                 ; AC3 = src - SDRAMTOP,

    ;set source addr lower and upper
    ;regs->CSSA_L = GETLOWORD((LgUns)src);
    MOV AC0, port(*AR3(short(#DDMA_ChanRegs.CSSA_L))) ; Pipe 4 just Ok for AR3 from MOV (due to prior pipeline delay for AR1)
    SUB dbl(*AR1+), AC0, AC2                   ; AC2 = src - (DARAMSIZE + SARAMSIZE)
    ;regs->CSSA_H = GETHIWORD((LgUns)src);
    MOV HI(AC0), port(*AR3(short(#DDMA_ChanRegs.CSSA_H)))

    XCCPART AC3 <= #0 || MOV #CSDP_SRCEMIF, T2 ; If (SDRAMTOP-src) >= 0 then
                                               ;     T2 = CSDP_SRCEMIF
    XCCPART AC2 < #0 || MOV #CSDP_SRCSARAM, T2 ; If DARAMSIZE + SARAMSIZE > src
                                               ;     then T2 = CSDP_SRCSARAM

    ;set destination addr lower and upper
    ;regs->CDSA_L = GETLOWORD((LgUns)dst);
    MOV AC1, port(*AR3(short(#DDMA_ChanRegs.CDSA_L)))
    SUB dbl(*AR1+), AC0                        ; AC0 = src - DARAMSIZE
    SUB dbl(*AR1+), AC1, AC2                   ; AC2 = dst - (DARAMSIZE+SARAMSIZE)
    XCCPART AC0 < #0 || MOV #CSDP_SRCDARAM, T2 ; If DARAMSIZE >= src then
                                               ;    T2 = CSDP_SRCDARAM

;******** Calculate Dst Port Value ********

    SUB dbl(*AR1+), AC1, AC3                    ; AC3 = dst - SDRAMTOP
    OR *AR0(short(#IDMA2_Obj.csdp)), T2, AR2    ; AR2 = handle->csdp | T2 =
                                                ;     handle->csdp | srcport
    XCCPART AC3 <= #0 || MOV #CSDP_DSTEMIF, T3  ; If SDRAMTOP >= dst then
                                                ;     T3 = CSDP_DSTEMIF
    ;regs->CDSA_H = GETHIWORD((LgUns)dst);
    MOV HI(AC1), port(*AR3(short(#DDMA_ChanRegs.CDSA_H)))
    XCCPART AC2 < #0 || MOV #CSDP_DSTSARAM, T3 ; If DARAMSIZE + SARAMSIZE >= dst
                                               ;     then T3 = CSDP_DSTSARAM
    SUB dbl(*AR1), AC1, AC3                    ; AC3 = dst - DARAMSIZE
    ||XOR #CSDP_SRCEMIF, T2, T1                ; T1 = T2 ^ CSDP_SRCEMIF =
                                               ;     srcport ^ CSDP_SRCEMIF
    XCCPART AC3 < #0 || MOV #CSDP_DSTDARAM, T3 ; If DARAMSIZE >= dst then
                                               ;     T3 = CSDP_DSTDARAM

;******** Calculation of Src and Dst Ports done ********

        ; NO LONGER set PACKED-BURST MODE here! 
        ; OR #CSDP_SRCDSTPKBEN_ENA, AR2 ; AR2 = AR2 | CSDP_SRCDSTPKBEN_ENA
        OR T3, AR2                      ; AR2 = AR2 | T3
                                        ; AR2 = srcport | dstport | handle->csdp
 
    XOR #CSDP_DSTEMIF, T3           ; T3 = T3 XOR CSDP_DSTEMIF =
                                    ;     dstport XOR CSDP_DSTEMIF
    OR T1, T3                       ; T3 = (srcport XOR CSDP_SRCEMIF) |
                                    ;     (dstport XOR CSDP_DSTEMIF)
    ||AADD #IDMA2_Obj.ccr, AR0      ; AR0  = AR0 + IDMA2_Obj.ccr =
                                    ;     address of handle->ccr

    ; HACK - must be resolved
  .if DISABLE_DATA_BURST_1510

    ;if( srcport == CSDP_SRCEMIF && dstport == CSDP_DSTEMIF)
    ;regs->CSDP &= 0x3FFF ; //disable dst bursting
     XCCPART T3 == #0 || AND #0x3fff, AR2 ; clear high 2 bits
  .endif

    ; regs->CSDP = srcport | dstport | handle->csdp ;

  .if _DISABLE_8BIT_PACKBURST
; DISABLE BURST/PACK MODE FOR 8 BIT TRANSFERS
     AND #1, AR2, T2
     XCCPART T2 == #0 || AND #0x1E3F, AR2
  .endif

* Note: increment AR3 so that subsequent ||ADD can use the k3 syntax
    MOV AR2, port(*AR3+)                 ; regs->CSDP = AR2
;                                        ; AR3 = &regs->CCR 
 .noremark 5573  ; CPU_43 BKxx & BSAxx updates not pipeline protected against MAR ops
    MOV dbl(*AR0+), AC0                  ; HI(AC0) = handle->ccr,
                                         ; LO(AC0) = handle->cfn
    ||AADD #DDMA_ChanRegs.CEN-DDMA_ChanRegs.CCR, AR3 ; AR3 = &regs->CEN
 .remark 5573  ; CPU_43 BKxx & BSAxx updates not pipeline protected against MAR ops

    MOV T0, port(*AR3+)                  ; regs->CEN = T0 = cnt
;                                        ; AR3 = &regs->CFN
    MOV dbl(*AR0+), AC1                  ; HI(AC1) = handle->csei,
                                         ; LO(AC1) = handle->csfi
    MOV AC0, port(*AR3+)                 ; regs->CFN = handle->cfn
;                                        ; AR3 = &regs->CSFI
    MOV dbl(*AR0+), AC2                  ; HI(AC2) = handle->cdei,
                                         ; LO(AC2) = handle->cdfi
    MOV AC1, port(*AR3+)                 ; regs->CSFI = handle->csfi
;                                        ; AR3 = &regs->CSEI
    MOV *AR0, AC3                        ; AC3 = handle->ccr2

;*****  Restore the saved XAR2 (curhandle) for Callback Notification fxn ****
;*****     Restore before next POP, and once AR2 is not used anymore
    MOV HI(AC1), port(*AR3+)             ; regs->CSEI = handle->csei
;                                        ; AR3 = &regs->CSACO
    POP AR2                              ; Note that only AR2 was pushed, not AR2H
    ||BSET #23, AC0                      ; AC0 = AC0 | (CCR_CHENABL << 16)
   
    MOV HI(AC2), port(*AR3(short(#DDMA_ChanRegs.CDEI-DDMA_ChanRegs.CSACO))) ; regs->CDEI = handle->cdei
    POP T3, T2                           ; Context restoring T3, T2
    MOV AC2, port(*AR3(short(#DDMA_ChanRegs.CDFI-DDMA_ChanRegs.CSACO)))     ; regs->CDFI = handle->cdfi


    ; End _DMA_load
    ; (Instrumented Version) don't restore XAR3 yet if instrumented. 
    ;                        Stack top contains XAR0 & T0
    ;                        Context restoring XAR3
    ; (Instrumented Version) commented out 
    ; (Instrumented Version)    POPBOTH XAR3

    ; program the ccr2 register for little endian dst/src ports for emifs
    ; regs->CCR2 = handle->ccr2
    MOV AC3, port(*AR3(short(#DDMA_ChanRegs.CCR2-DDMA_ChanRegs.CSACO)))      ; regs->CCR2 = handle->ccr2

    ; Enable this DMA channel
    ; regs->CCR |= CCR_CHANENABL
    MOV HI(AC0), port(*AR4(short(#DDMA_ChanRegs.CCR)))

  .if _INSTR_BANDWIDTH

    ; Matches CASE 2: in _ACPY2_OMAP_updateChannelStats
    ; ******* instrumentation call for DMA bandwidth data *******
    ;       ACPY2_OMAP_updateChannelStats(handle, cnt);
    ;           handle          ;IDMA2_handle, passed in XAR0
    ;           Cnt             ; unsigned Count, passed in T0
    ;       Restore AR0 and TO, and we don't need to preserve
    ;       anything else modified by updateChannelStats ...

    ;       call ACPY2_OMAP_updateChannelStats with saved handle and cnt
    POP T0         ; T0  == job->cnt        ;
    POPBOTH XAR0

    SAVE_CONTEXT_FOR_MY_C
    CALL #_ACPY2_OMAP_updateChannelStats     ; input args: XAR0 and T0
    RESTORE_CONTEXT_FOR_MY_C 
   
  .endif ; if _INSTR_BANDWIDTH
   ; ********end instrumented ********************************** 

;******** end DMA_load *************
    ; (Instrumented Version) moved restoring of XAR3, T3, T2 to here
    ;                        -- was above --
    ; Context restoring XAR3, T3, T2
    ; Context restoring AC0, AC3, XAR0
  .if (_INSTR_BANDWIDTH == 0) | (OPTIMIZE_FOR_SIZE == 0)
    POP T1, T0                          ; Context restoring T1, T0
  .endif
    POPBOTH XAR3
    POP mmap(AC0G)
    POP dbl(AC0)
    POP mmap(AC3G)
    POP dbl(AC3)
    POPBOTH XAR0

LABEL1:

    ; ***** Callback Notification Support *****
    ; See if currently completed transfer's handle has a non-NULL callback
    ; function. If it does, call the function with the provided cbArg before 
    ; returning from the ISR.
    MOV dbl(*+AR2(#IDMA2_Obj.cbFxn)), AC2    ; AR2 = &handle->cbFxn

* Restore those registers that can be restored

  .if _INSTR_BANDWIDTH & OPTIMIZE_FOR_SIZE
    POP T1, T0  ; save 
  .endif
    POP mmap(AC1G)
    POP dbl(AC1)
    POPBOTH XAR1

    BCC LABEL_CALLBACK, AC2 != #0        ; Pipe 1 Ok from MOV for AC2

    DMAN_EPILOG_MAC        ; restore registers 

 .noremark 5674 ; CPU_99 If processor is in fast-return mode and this return is stalled in ADDRESS or ACCESS1
*               ; phase, then the execution of a subsequent conditional execution may be corrupted.
 .noremark 5675 ; no MMR write to RPTC near here
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    ;NOP       ;     avoids Silicon Exception CPU_99/100
    
* Exit ISR and re-enable interrupts    
    RETI        ; return from ISR occurs
 .remark 5674
 .remark 5675 
    .endm








MACRO_DMA_cisr  .macro  DMA_REG, ChNum, LABEL1, LABEL3
*
* Note: ST0, ST1, and ST2 are automatically save and restored
* by the Automatic Context Switch mechanism of an ISR.
*

* Modify ST2 for a C-callable routine
   .noremark 5601    
    MOV #0xf000,mmap(ST2_55)    ; Reset RDM and all circ modes, set ARMS_ON
   .remark 5601    
 .arms_on    
 
    AND #0x791f, mmap(ST1_55)   ; Turn off BRAF, M40, SATD, C16, FRCT, C54CM
*                ; SXMD and CPL will be turned on later only if subroutines are called
 
    ; Context saving AC2, XAR4
    PSHBOTH XAR4
    PSH dbl(AC2)
    
    ; jobQ = _DMA_jobQueue[chanNum)]
    MOV dbl(*(#(__DMA_jobQueue+ChNum))), XAR4 ; (Pipe 4 just Ok for XAR4 for MOV)
    
    PSH mmap(AC2G)

    ;dummy = *((ioport int *)DMA_REG);
    MOV port(#DMA_REG), AC2

  .if _INSTR_BANDWIDTH & OPTIMIZE_FOR_SIZE
    PSH T1, T0  ; save 
    MOV #(ChNum >> 1), T0   ; CASE 1: pass ChanId in cnt argument with 
                            ; handle == NULL, ChNum is ChannelNumber*2
  .endif

 .if OPTIMIZE_FOR_SIZE
    PSHBOTH XAR2
    ||B DmaIsrMergedCode
 .else
    PSHBOTH XAR2
    DMA_GUTS_MAC    ChNum, LABEL1, LABEL3
 .endif
    .endm

;/d============================================================================
;/d    FUNCTION NAME: _dmanIsr0(              ;returns void
;/d                         );
;/D                 to _dmanIsr5( returns void);
;/d Description      : Interrupt service routine; Remove dma job from queue,
;/d                        and start new job if any.
;/d Function Type    : ISR
;/d Assumptions      : none
;/d    Notes            :
;/d    call frequency   : -
;/d    cycle count      : 153 cycles on omap1510 EVM
;/d Function Uses Regs : AC0,AC1,AC2,AC3,T0,T1,T2,T3,XAR0,XAR1,XAR2,XAR3,XAR4
;/d Save On Entry Regs : AC0,AC1,AC2,AC3,T0,T1,T2,T3,XAR0,XAR1,XAR2,XAR3,XAR4
;/d----------------------------------------------------------------------------

    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr0:
    ;dummy = *((ioport int *)DMA0_STATUS_REG);
    ;DMA_cisr(0);
    MACRO_DMA_cisr DMA0_STATUS_REG, CH0, DMA_CISR_0, L0_0
    
    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr1:
    ;dummy = *((ioport int *)DMA1_STATUS_REG);
    ;DMA_cisr(1);
        MACRO_DMA_cisr DMA1_STATUS_REG, CH1, DMA_CISR_1, L1_0
    
    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr2:
    ;dummy = *((ioport int *)DMA2_STATUS_REG);
    ;DMA_cisr(2);
        MACRO_DMA_cisr DMA2_STATUS_REG, CH2, DMA_CISR_2, L2_0

    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr3:
    ;dummy = *((ioport int *)DMA3_STATUS_REG);
    ;DMA_cisr(3);
        MACRO_DMA_cisr DMA3_STATUS_REG, CH3, DMA_CISR_3, L3_0

    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr4:
    ;dummy = *((ioport int *)DMA4_STATUS_REG);
    ;DMA_cisr(4);
        MACRO_DMA_cisr DMA4_STATUS_REG, CH4, DMA_CISR_4, L4_0

    .sect    ".text:ACPY_internal"
    .align 4
_dmanIsr5:
    ;dummy = *((ioport int *)DMA5_STATUS_REG);
    ;DMA_cisr(5);
        MACRO_DMA_cisr DMA5_STATUS_REG, CH5, DMA_CISR_5, L5_0


************************************************************************************

 .if OPTIMIZE_FOR_SIZE
    .sect    ".text:ACPY_internal"
    .align 4
DmaIsrMergedCode:
    DMA_GUTS_MAC    -1, EndOfIsr, JobsArePending
 .endif

* Calling the callback function and then exiting the ISR
* can be merged for all of the DMAs.  There is nothing
* particular to any DMA at this point.

    .sect    ".text:ACPY_isr"
    .align 4
LABEL_CALLBACK:

*
* Temporarily save AR2 in data-space (i.e. ACPY2_callbackPtr), so that
* it won't be overwritten when the registers are restored to their
* original values to allow for HWI_enter.
*
    MOV XAR2, dbl(*(#ACPY2_callbackPtr))        ; ACPY2_callbackPtr = &IDMA2_Obj.cbFxn

    DMAN_EPILOG_MAC        ; restore registers to original values when ISR was entered

    HWI_enter C55_AR_DR_SAVE_BY_CALLER_MASK, \
              C55_ACC_SAVE_BY_CALLER_MASK,   \
              C55_MISC1_SAVE_BY_CALLER_MASK, \
              C55_MISC2_SAVE_BY_CALLER_MASK, \
              C55_MISC3_SAVE_BY_CALLER_MASK, \
              0xffff, 0xffff

    MOV dbl(*(#ACPY2_callbackPtr)), XAR2 ; (Pipe 0 of 4 for MOV)
    MOV dbl(*AR2+), AC2    ; AC2 = IDMA2_Obj.cbFxn;   (callback function)
*                          ; AR2 = &IDMA2_Obj.cbArg
 .if   (IDMA2_Obj.cbArg == (IDMA2_Obj.cbFxn+2))
    MOV dbl(*AR2), XAR0                                                 ; argument for callback function
 .else
    MOV dbl(*AR2(short(#IDMA2_Obj.cbArg-(IDMA2_Obj.cbFxn+2)))), XAR0    ; argument for callback function
 .endif

    CALL AC2

    HWI_exit  C55_AR_DR_SAVE_BY_CALLER_MASK, \
              C55_ACC_SAVE_BY_CALLER_MASK,   \
              C55_MISC1_SAVE_BY_CALLER_MASK, \
              C55_MISC2_SAVE_BY_CALLER_MASK, \
              C55_MISC3_SAVE_BY_CALLER_MASK, \
              0xffff, 0xffff

************************************************************************************


    .remark 5674
    .endif ; defined DMA_OPT

