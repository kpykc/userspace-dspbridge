;  ======== mgs3/acpy2_wait.s55 ========
;
; This file implements ACPY2_wait assembly routine
;
;

    .if DMA_OPT

;==============================================================================
;includes
;------------------------------------------------------------------------------

;/d============================================================================
;/d function prototype and global variables
;/d----------------------------------------------------------------------------

    .def _ACPY2_wait

;/d****************************************************************************
;/d* UNDEFINED EXTERNAL REFERENCES                                            *
;/d****************************************************************************


;******************************************************************************
;* CONSTANTS                                                                  *
;******************************************************************************


;/d============================================================================
;/d macros
;/d----------------------------------------------------------------------------
;********************

;Remarks disabled
    ;.noremark 5573
    ;.noremark 5571
    ;.noremark 5650
    ;.noremark 5673


;/d============================================================================
;/d     FUNCTION NAME: ACPY2_wait(              ;returns void
;/d         handle          ;IDMA2_handle, passed in XAR0
;/d                         );
;/d Description: Wait for all data transfer on logical channel to complete.
;/d              This implementation does a TSK_yield while waiting for all
;/d              outstanding jobs to complete. Other implementations might
;/d              do other processing while waiting.
;/d Function Type    : "c" callable
;/d Assumptions      : none
;/d     Notes            :
;/d     call frequency   : -
;/d     cycle count      : 17 cycles on omap1510 EVM
;/d Function Uses Regs : AR0
;/d Save On Entry Regs : -
;/d----------------------------------------------------------------------------

    .sect    ".text:ACPY_internal"
    .align 4

_ACPY2_wait:
ACPY_WAIT_L2:
    ; AR0 contains "handle"
    ; The first field in the "handle" structure is numJobs

    ; Consider inserting TSK_yield() here when _RTS_MODE is not defined
    ; while (handle->numJobs > 0) { goto ACPY2_WAIT_L2 }
    ;;    BCC ACPY_WAIT_L2,AR1 > #0 
    ;;    RET                          ; Return to the calling function

*
* This function should return as quickly as possible after handle->numJobs is 
* decremented to 0 by an ISR.  It is especially important that the function
* returns as quick as it can in the event that handle->numJobs has already
* been decremented to 0 before the function is called. So the code was written
* to return in this case after only 2 instructions.
* In this implementation, the MOV and RETCC pair is repeated 5 times.  This is 
* a small sacrifice of extra code-space to hopefully speed up the return
* after an ISR completes.  We hop to catch the return from an ISR between 
* a RETCC and a MOV.  In the event that it happens at the end of the set of 5
* RETCC statements, then the extra branch to go back to the top will cause the
* delay to be the same as the original code.  But this should be only a 20% 
* chance.  Certainly, the MOV/RETCC pair could be copied indefinitely, but
* 5 should be a good compromise between usefulness and size.
*
    MOV *AR0, AR1                       ; AR1 = handle->numJobs
    RETCC AR1 == #0
    
    MOV *AR0, AR1                       ; AR1 = handle->numJobs
    RETCC AR1 == #0
    
    MOV *AR0, AR1                       ; AR1 = handle->numJobs
    RETCC AR1 == #0
    
    MOV *AR0, AR1                       ; AR1 = handle->numJobs
    RETCC AR1 == #0
    
    MOV *AR0, AR1                       ; AR1 = handle->numJobs
    RETCC AR1 == #0
    
    B ACPY_WAIT_L2
    
    .endif ; defined DMA_OPT
