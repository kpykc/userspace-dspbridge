*
*  ======== dma4/idma2.h55 ========
*  Declaration of the IDMA2 interface.
*

 .if !$isdefed("IDMA2_H55_")
IDMA2_H55_  .equ 1

*
*  ======== IDMA2_Handle ========
*  Handle to "logical" DMA channel.
*
* typedef struct IDMA2_Obj *IDMA2_Handle;

* typedef Void (*IDMA2_AdrPtr)();
* #define IDMA2_ADRPTR(addr) ((IDMA2_AdrPtr)((LgUns)addr<<1))

*
*  ======== IDMA2_ElementSize ========
*  8, 16 or 32-bit aligned transfer.
*
* typedef enum IDMA2_ElementSize {
*    IDMA2_ELEM8,         ; 8-bit data element 
*    IDMA2_ELEM16,        ; 16-bit data element 
*    IDMA2_ELEM32         ; 32-bit data element 
* } IDMA2_ElementSize;

IDMA2_ELEM8	.set 0  ; 8-bit data element 
IDMA2_ELEM16	.set 1  ; 16-bit data element 
IDMA2_ELEM32	.set 2  ; 32-bit data element 

*
*  ======== IDMA2_TransferType ========
*  Type of the DMA transfer.
*
* typedef enum IDMA2_TransferType {
*   IDMA2_1D1D,          ; 1-dimensional to 1-dimensional transfer 
*   IDMA2_1D2D,          ; 1-dimensional to 2-dimensional transfer 
*   IDMA2_2D1D,          ; 2-dimensional to 1-dimensional transfer 
*   IDMA2_2D2D           ; 2-dimensional to 2-dimensional transfer 
* } IDMA2_TransferType;

IDMA2_1D1D .set 0 ; 1-dimensional to 1-dimensional transfer 
IDMA2_1D2D .set 1 ; 1-dimensional to 2-dimensional transfer 
IDMA2_2D1D .set 2 ; 2-dimensional to 1-dimensional transfer 
IDMA2_2D2D .set 3 ; 2-dimensional to 2-dimensional transfer 

*
*  ======== IDMA2_Params ========
*  DMA transfer specific parameters. Defines the configuration of a
*  logical channel.
*
IDMA2_Params		.struct
xType		.int ; IDMA2_TransferType ; 1D1D, 1D2D, 2D1D or 2D2D 
elemSize	.int ; IDMA2_ElementSize  ; Element transfer size 
numFrames	.int ; Uns       ; Num of frames for 2D transfers 
srcElementIndex	.int ; In 8-bit bytes  
dstElementIndex	.int ; In 8-bit bytes 
srcFrameIndex	.int ; Jump in 8-bit bytes for 2D transfers 
dstFrameIndex	.int ; Jump in 8-bit bytes for 2D transfers 
IDMA2_ParamsSize	.endstruct	; 7 words

*
*  ======== IDMA2_ChannelRec ========
*  DMA record used to describe the logical channels. 
*
IDMA2_ChannelRec	.struct
handle		.long    ; IDMA2_Handle  ; Handle to logical DMA channel 
queueId		.int     ; Selects the serialization queue 
filler		.int     ; (for alignment only)
IDMA2_ChannelRecSize	.endstruct	; 4 words

*
*  ======== IDMA2_Fxns ========
*  These fxns are used to query/grant the DMA resources requested by
*  the algorithm at initialization time, and to change these resources
*  at runtime. All these fxns are implemented by the algorithm, and
*  called by the client of the algorithm.
*
*    implementationId    - unique pointer that identifies the module
*                          implementing this interface.
*    dmaChangeChannels() - apps call this whenever the logical channels
*                          are moved at runtime.
*    dmaGetChannelCnt()  - apps call this to query algorithm about max
*                          number of logical dma channel requested.
*    dmaGetChannels()    - apps call this to query algorithm about its
*                          dma channel requests at init time, or to get
*                          the current channel holdings.
*    dmaInit()           - apps call this to grant dma handle(s) to the
*                          algorithm at initialization. Algorithm initializes
*                          the instance object.
*
IDMA2_Fxns	.struct
implementationId  .long	; Void *implementationId	.long	; Void *
dmaChangeChannels .long	; Void (*dmaChangeChannels)(IALG_Handle, IDMA2_ChannelRec *);
dmaGetChannelCnt  .long ; Int  (*dmaGetChannelCnt)(Void);
dmaGetChannels    .long ; Int  (*dmaGetChannels)(IALG_Handle, IDMA2_ChannelRec *);
dmaInit           .long ; Int  (*dmaInit)(IALG_Handle, IDMA2_ChannelRec *);
IDMA2_FxnsSize	.endstruct	; 10 words

 .endif ; if !$isdefed("IDMA2_H55_")
