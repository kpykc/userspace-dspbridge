<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Framework Components: IALG_Fxns Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul></div>
<h1>IALG_Fxns Struct Reference<br>
<small>
[<a class="el" href="group__ti__xdais___i_a_l_g.html">IALG - xDAIS Algorithm Interface</a>]</small>
</h1><!-- doxytag: class="IALG_Fxns" --><code>#include &lt;<a class="el" href="ialg_8h-source.html">ialg.h</a>&gt;</code>
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines the fields and methods that must be supplied by all xDAIS algorithms. 
<p>

<p>
Definition at line <a class="el" href="ialg_8h-source.html#l00187">187</a> of file <a class="el" href="ialg_8h-source.html">ialg.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#83963e2ca17632c15bdb01494481a615">implementationId</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unique pointer that identifies the module implementing this interface.  <a href="#83963e2ca17632c15bdb01494481a615"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notification to the algorithm that its memory is "active" and algorithm processing methods may be called.  <a href="#f1213efc8ac6fdfb72b50da9950baaa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc</a> )(const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params, struct <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a> **parentFxns, <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apps call this to query the algorithm about its memory requirements. Must be non-NULL.  <a href="#1640ba8f4033af1ce3887283c7a12746"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, <a class="el" href="group__ti__xdais___i_a_l_g.html#g9032f20923ef2ba1d6b88c87a20075fa">IALG_Cmd</a> cmd, <a class="el" href="struct_i_a_l_g___status.html">IALG_Status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Algorithm specific control and status.  <a href="#4c506a1599a604b02b30097e61ff4b89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save all persistent data to non-scratch memory.  <a href="#10f29860ab8b3beab69b0f0128c3d969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#c6f87b240d96486e3e88e80b95046ade">algFree</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apps call this to allow the algorithm to initialize memory requested via <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a>. Must be non-NULL.  <a href="#c6f87b240d96486e3e88e80b95046ade"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, const <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab, <a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> parent, const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an algorithm's instance object. Must be non-NULL.  <a href="#94eca7c58cceb112eccd970a6cf3f569"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#5456c5087825b808e18000c551a66ef1">algMoved</a> )(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, const <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab, <a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> parent, const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify algorithm instance that instance memory has been relocated.  <a href="#5456c5087825b808e18000c551a66ef1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc</a> )(Void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of memory allocation requests required.  <a href="#098c1ca275465bb4acc1d3d0cf060160"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="83963e2ca17632c15bdb01494481a615"></a><!-- doxytag: member="IALG_Fxns::implementationId" ref="83963e2ca17632c15bdb01494481a615" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Void* <a class="el" href="struct_i_a_l_g___fxns.html#83963e2ca17632c15bdb01494481a615">IALG_Fxns::implementationId</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unique pointer that identifies the module implementing this interface. 
<p>

<p>
Definition at line <a class="el" href="ialg_8h-source.html#l00192">192</a> of file <a class="el" href="ialg_8h-source.html">ialg.h</a>.
</div>
</div><p>
<a class="anchor" name="f1213efc8ac6fdfb72b50da9950baaa7"></a><!-- doxytag: member="IALG_Fxns::algActivate" ref="f1213efc8ac6fdfb72b50da9950baaa7" args=")(IALG_Handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Void(* <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">IALG_Fxns::algActivate</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notification to the algorithm that its memory is "active" and algorithm processing methods may be called. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Handle to an algorithm instance.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> initializes any of the instance's scratch buffers using the persistent memory that is part of the algorithm's instance object.<p>
The implementation of <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> is optional. The <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> method should only be implemented if a module wants to factor out initialization code that can be executed once prior to processing multiple consecutive frames of data.<p>
If a module does not implement this method, the <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> field in the module's static function table (of type <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a>) must be set to <code>NULL</code>. This is equivalent to the following implementation: <div class="fragment"><pre class="fragment">      Void <a class="code" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate</a>(<a class="code" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)
      {
      }
</pre></div></dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> can only be called after a successful return from <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>.<p>
<code>handle</code> must be a valid handle for the algorithm's instance object.<p>
No other algorithm method is currently being run on this instance. This method never preempts any other method on the same instance.<p>
If the algorithm has implemented the IDMA2 interface, <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> can only be called after a successful return from dmaInit().</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>All methods related to the algorithm may now be executed by client (subject to algorithm specific restrictions).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1640ba8f4033af1ce3887283c7a12746"></a><!-- doxytag: member="IALG_Fxns::algAlloc" ref="1640ba8f4033af1ce3887283c7a12746" args=")(const IALG_Params *params, struct IALG_Fxns **parentFxns, IALG_MemRec *memTab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int(* <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">IALG_Fxns::algAlloc</a>)(const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params, struct <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a> **parentFxns, <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apps call this to query the algorithm about its memory requirements. Must be non-NULL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Algorithm specific attributes. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>parentFxns</em>&nbsp;</td><td>Parent algorithm functions. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>memTab</em>&nbsp;</td><td>array of memory records.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> returns a table of memory records that describe the size, alignment, type and memory space of all buffers required by an algorithm (including the algorithm's instance object itself). If successful, this function returns a positive non-zero value indicating the number of records initialized. This function can never initialize more memory records than the number returned by <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a>.<p>
If <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> is not implemented, the maximum number of initialized memory records is <a class="el" href="group__ti__xdais___i_a_l_g.html#g8a220fa863380937542f6a38be47ceda">IALG_DEFMEMRECS</a>.<p>
The first argument to <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> is a pointer to the creation parameters for the instance of the algorithm object to be created. This pointer is algorithm-specific; i.e., it points to a structure that is defined by each particular algorithm. This pointer may be <code>NULL</code>; however, in this case, <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> must assume default creation parameters and must not fail.<p>
The second argument to <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> is an optional parameter. <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> may return a pointer to its parent's IALG functions. If this output value is assigned a non-NULL value, the client must create the parent instance object using the designated IALG functions pointer. The parent instance object must then be passed to <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>.<p>
<a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> may be called at any time and it must be idempotent; i.e., it can be called repeatedly without any side effects, and always returns the same result.</dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The number of memory records in the array <code>memTab</code>[] is no less than the number returned by <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a>.<p>
<code>*parentFxns</code> is a valid pointer to an <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a> pointer variable.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If the algorithm needs a parent object to be created, the pointer <code>*parentFxns</code> is set to a non-NULL value that points to a valid <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a> structure, the parent's IALG implementation. Otherwise, this pointer is not set. <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> may elect to ignore the <code>parentFxns</code> pointer altogether.<p>
For each memory descriptor in memTab with an IALG_WRITEONCE attribute, the algorithm has either set the base field to a non-NULL value, which is the address of a statically allocated and initialized memory buffer of the indicated 'size', or has set the base field to <code>NULL</code>, thereby requiring the memory for the buffer to be provided by the client.<p>
Exactly <br>
 elements of the <code>memTab</code>[] array are initialized, where <code>n</code> is the return value from this operation.<p>
For each memory descriptor in <code>memTab</code> with an IALG_PERSIST or IALG_SCRATCH attribute, the algorithm does not set its base field.<p>
<code>memTab</code>[0] defines the memory required for the instance's object and this object's first field is an <a class="el" href="struct_i_a_l_g___obj.html">IALG_Obj</a> structure.<p>
<code>memTab</code>[0] is requested as persistent memory.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#c6f87b240d96486e3e88e80b95046ade">algFree()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c506a1599a604b02b30097e61ff4b89"></a><!-- doxytag: member="IALG_Fxns::algControl" ref="4c506a1599a604b02b30097e61ff4b89" args=")(IALG_Handle handle, IALG_Cmd cmd, IALG_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int(* <a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">IALG_Fxns::algControl</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, <a class="el" href="group__ti__xdais___i_a_l_g.html#g9032f20923ef2ba1d6b88c87a20075fa">IALG_Cmd</a> cmd, <a class="el" href="struct_i_a_l_g___status.html">IALG_Status</a> *status)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Algorithm specific control and status. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Algorithm instance handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmd</em>&nbsp;</td><td>Algorithm specific command. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>status</em>&nbsp;</td><td>Algorithm specific status.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl()</a> sends an algorithm specific command, <code>cmd</code>, and an input/output status buffer pointer to an algorithm's instance object.<p>
In preemptive execution environments, <a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl()</a> may preempt a module's other metods (for example, its processing methods).<p>
The implementation of <a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl()</a> is optional. If a module does not implement this method, the <a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl()</a> field in the module's static function table (of type <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a>) must be set to <code>NULL</code>. This is equivalent to the following implementation: <div class="fragment"><pre class="fragment">      Void <a class="code" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl</a>(<a class="code" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, <a class="code" href="group__ti__xdais___i_a_l_g.html#g9032f20923ef2ba1d6b88c87a20075fa">IALG_Cmd</a> cmd, <a class="code" href="struct_i_a_l_g___status.html">IALG_Status</a> *status)
      {
          <span class="keywordflow">return</span> (<a class="code" href="group__ti__xdais___i_a_l_g.html#g604e5600815cbd58846e0c5c05b6ba18">IALG_EFAIL</a>);
      }
</pre></div></dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#4c506a1599a604b02b30097e61ff4b89">algControl()</a> can only be called after a successful return from <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>.<p>
<code>handle</code> must be a valid handle for the algorithm's instance object.<p>
Algorithm specific <code>cmd</code> values are always less than IALG_SYSCMD.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If the <code>cmd</code> value is not recognized by the algorithm, the return value is not equal to IALG_EOK.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="10f29860ab8b3beab69b0f0128c3d969"></a><!-- doxytag: member="IALG_Fxns::algDeactivate" ref="10f29860ab8b3beab69b0f0128c3d969" args=")(IALG_Handle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Void(* <a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">IALG_Fxns::algDeactivate</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save all persistent data to non-scratch memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Algorithm instance handle.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a> saves any persistent information to non-scratch buffers using the persistent memory that is part of the algorithm's instance object.<p>
<code>handle</code> is used by the algorithm to identify the various buffers that must be saved prior to the next cycle of <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> and processing.<p>
The implementation of <a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a> is optional. The <a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a> method is only implemented if a module wants to factor out initialization code that can be executed once prior to processing multiple consecutive frames of data.<p>
If a module does not implement this method, the <a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a> field in the module's static function table (of type <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a>) must be set to <code>NULL</code>. This is equivalent to the following implementation: <div class="fragment"><pre class="fragment">      Void <a class="code" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate</a>(<a class="code" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle)
      {
      }
</pre></div></dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#10f29860ab8b3beab69b0f0128c3d969">algDeactivate()</a> can only be called after a successful return from <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>.<p>
The instance object is currently "active"; i.e., all instance memory is active and if an <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> method is defined, it has been called.<p>
<code>handle</code> must be a valid handle for the algorithm's instance object.<p>
No other algorithm method is currently being run on this instance. This method never preempts any other method on the same instance.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>No methods related to the algorithm may now be executed by the client; only <a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> or <a class="el" href="struct_i_a_l_g___fxns.html#c6f87b240d96486e3e88e80b95046ade">algFree()</a> may be called.<p>
All instance scratch memory may be safely overwritten.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#f1213efc8ac6fdfb72b50da9950baaa7">algActivate()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6f87b240d96486e3e88e80b95046ade"></a><!-- doxytag: member="IALG_Fxns::algFree" ref="c6f87b240d96486e3e88e80b95046ade" args=")(IALG_Handle handle, IALG_MemRec *memTab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int(* <a class="el" href="struct_i_a_l_g___fxns.html#c6f87b240d96486e3e88e80b95046ade">IALG_Fxns::algFree</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apps call this to allow the algorithm to initialize memory requested via <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a>. Must be non-NULL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Algorithm instance handle. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>memTab</em>&nbsp;</td><td>Output array of memory records.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#c6f87b240d96486e3e88e80b95046ade">algFree()</a> returns a table of memory records that describe the base address, size, alignment, type and memory space of all buffers previously allocated for the algorithm's instance (including the algorithm's instance object itself) specified by <code>handle</code>. This function always returns a positive non-zero value indicating the number of records initialized. This function can never initialize more memory records than the value returned by <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a>.</dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The <code>memTab</code>[] array contains at least <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> records.<p>
<code>handle</code> must be a valid handle for the algorithm's instance object.<p>
If the prior call to <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> returned a non-NULL parent functions pointer, then the parent instance must be an active instance object created via that function pointer.<p>
No other agorithm method is currently being run on this instance. This method never preempts any other method on the same instance.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><code>memTab</code>[] contains pointers to all of the memory passed to the algorithm via <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>.<p>
The size and alignment fields contain the same values passed to the client via <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a>; i.e., if the client makes changes to the values returned via <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> and passes these new values to <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>, the algorithm is not responsible for retaining any such changes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="94eca7c58cceb112eccd970a6cf3f569"></a><!-- doxytag: member="IALG_Fxns::algInit" ref="94eca7c58cceb112eccd970a6cf3f569" args=")(IALG_Handle handle, const IALG_MemRec *memTab, IALG_Handle parent, const IALG_Params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int(* <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">IALG_Fxns::algInit</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, const <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab, <a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> parent, const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize an algorithm's instance object. Must be non-NULL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Algorithm instance handle. This is a pointer to an initialized <a class="el" href="struct_i_a_l_g___obj.html">IALG_Obj</a> structure. Its value is identical to the memTab[0].base. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memTab</em>&nbsp;</td><td>Array of allocated buffers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>Handle of algorithm's parent instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Pointer to algorithm's instance parameters.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a> performs all initialization necessary to complete the run-time creation of an algorithm's instance object. After a successful return from <a class="el" href="struct_i_a_l_g___fxns.html#94eca7c58cceb112eccd970a6cf3f569">algInit()</a>, the algorithm's instance object is ready to be used to process data. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5456c5087825b808e18000c551a66ef1"></a><!-- doxytag: member="IALG_Fxns::algMoved" ref="5456c5087825b808e18000c551a66ef1" args=")(IALG_Handle handle, const IALG_MemRec *memTab, IALG_Handle parent, const IALG_Params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Void(* <a class="el" href="struct_i_a_l_g___fxns.html#5456c5087825b808e18000c551a66ef1">IALG_Fxns::algMoved</a>)(<a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> handle, const <a class="el" href="struct_i_a_l_g___mem_rec.html">IALG_MemRec</a> *memTab, <a class="el" href="struct_i_a_l_g___obj.html">IALG_Handle</a> parent, const <a class="el" href="struct_i_a_l_g___params.html">IALG_Params</a> *params)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify algorithm instance that instance memory has been relocated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Algorithm instance handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memTab</em>&nbsp;</td><td>Array of allocated buffers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>Handle of algorithm's parent instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Pointer to algorithm's instance parameters.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#5456c5087825b808e18000c551a66ef1">algMoved()</a> performs any reinitialization necessary to insure that, if an algorithm's instance object has been moved by the client, all internal data references are recomputed.<p>
The implementation of <a class="el" href="struct_i_a_l_g___fxns.html#5456c5087825b808e18000c551a66ef1">algMoved()</a> is optional. However, it is highly recommended that this method be implemented. If a module does not implement this method, the <a class="el" href="struct_i_a_l_g___fxns.html#5456c5087825b808e18000c551a66ef1">algMoved()</a> field in the module's static function table (of type <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a>) must be set to <code>NULL</code>. This is equivalent to asserting that the algorithm's instance objects cannot be moved. </dd></dl>

</div>
</div><p>
<a class="anchor" name="098c1ca275465bb4acc1d3d0cf060160"></a><!-- doxytag: member="IALG_Fxns::algNumAlloc" ref="098c1ca275465bb4acc1d3d0cf060160" args=")(Void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int(* <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">IALG_Fxns::algNumAlloc</a>)(Void)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of memory allocation requests required. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> returns the maximum number of memory allocation requests that the <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> method requires. This operation allows clients to allocate sufficient space to call the <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> method or fail because insufficient space exists to support the creation of the algorithm's instance object. <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> may be called at any time, and it must be idempotent; i.e., it can be called repeatedly without any side effects, and always returns the same result.<p>
<a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> is optional; if it is not implemented, the maximum number of memory records for <a class="el" href="struct_i_a_l_g___fxns.html#1640ba8f4033af1ce3887283c7a12746">algAlloc()</a> is assumed to be <a class="el" href="group__ti__xdais___i_a_l_g.html#g8a220fa863380937542f6a38be47ceda">IALG_DEFMEMRECS</a>. This is equivalent to the following implementation: <div class="fragment"><pre class="fragment">      Void <a class="code" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc</a>(Void)
      {
          <span class="keywordflow">return</span> (IALG_DEFNUMRECS);
      }
</pre></div><p>
If a module does not implement this method, the <a class="el" href="struct_i_a_l_g___fxns.html#098c1ca275465bb4acc1d3d0cf060160">algNumAlloc()</a> field in the module's static function table (of type <a class="el" href="struct_i_a_l_g___fxns.html">IALG_Fxns</a>) must be set to <code>NULL</code>. </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ialg_8h-source.html">ialg.h</a></ul>
<hr size="1"><small>
Copyright  2007, Texas Instruments Incorporated</small>
</body>
</html>
